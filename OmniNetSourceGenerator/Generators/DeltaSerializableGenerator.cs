using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using SourceGenerator.Extensions;
using SourceGenerator.Helpers;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace OmniNetSourceGenerator
{
    [Generator]
    internal class DeltaSerializableGenerator : ISourceGenerator
    {
        public void Execute(GeneratorExecutionContext context)
        {
            if (context.SyntaxReceiver is DeltaSerializableSyntaxReceiver receiver)
            {
                if (receiver.structs.Any())
                {
                    foreach (StructDeclarationSyntax @struct in receiver.structs)
                    {
                        StringBuilder sb = new StringBuilder();
                        sb.AppendLine("#nullable disable");
                        sb.AppendLine("#pragma warning disable");
                        sb.AppendLine();

                        StructDeclarationSyntax parentStruct = @struct.Clear(out var fromStruct);
                        foreach (var usingSyntax in fromStruct.SyntaxTree.GetRoot().GetDescendantsOfType<UsingDirectiveSyntax>())
                            sb.AppendLine(usingSyntax.ToString());

                        if (parentStruct.HasModifier(SyntaxKind.PartialKeyword))
                        {
                            NamespaceDeclarationSyntax currentNamespace = fromStruct.GetNamespace(out bool hasNamespace);
                            if (hasNamespace) currentNamespace = currentNamespace.Clear(out _);

                            var members = fromStruct.Members
                                .Where(m => m is FieldDeclarationSyntax || m is PropertyDeclarationSyntax)
                                .ToList();

                            // Ler o parâmetro Enabled do atributo
                            bool enabled = true; // valor padrão
                            var attribute = fromStruct.GetAttribute("DeltaSerializable");
                            if (attribute != null)
                            {
                                var enabledExpression = attribute.GetArgumentExpression<LiteralExpressionSyntax>("Enabled", ArgumentIndex.First);
                                if (enabledExpression != null)
                                {
                                    if (bool.TryParse(enabledExpression.Token.ValueText, out bool enabledValue))
                                    {
                                        enabled = enabledValue;
                                    }
                                }
                            }

                            var writeDeltaMethod = CreateWriteDeltaMethod(members, parentStruct.Identifier.Text, enabled, context);
                            var readDeltaMethod = CreateReadDeltaMethod(members, enabled, context);

                            parentStruct = parentStruct.AddMembers(writeDeltaMethod, readDeltaMethod);

                            if (!hasNamespace)
                            {
                                sb.AppendLine("// Generated by OmniNetSourceGenerator");
                                sb.Append(parentStruct.NormalizeWhitespace().ToString());
                            }
                            else
                            {
                                currentNamespace = currentNamespace.AddMembers(parentStruct);
                                sb.AppendLine("// Generated by OmniNetSourceGenerator");
                                sb.Append(currentNamespace.NormalizeWhitespace().ToString());
                            }

                            context.AddSource($"{parentStruct.Identifier.Text}_delta_serializable_generated_code_.cs", sb.ToString());
                        }
                        else
                        {
                            GenHelper.ReportPartialKeywordRequirement(new Context(context), fromStruct);
                        }
                    }
                }
            }
        }

        private MethodDeclarationSyntax CreateReadDeltaMethod(List<MemberDeclarationSyntax> members, bool enabled, GeneratorExecutionContext context)
        {
            var statements = new List<StatementSyntax>();
            var validMembers = new List<MemberDeclarationSyntax>();

            // Filtrar apenas membros que são tipos de valor
            foreach (var member in members)
            {
                TypeSyntax memberType = member is FieldDeclarationSyntax fieldDecl
                    ? fieldDecl.Declaration.Type
                    : ((PropertyDeclarationSyntax)member).Type;

                var semanticModel = context.Compilation.GetSemanticModel(member.SyntaxTree);
                var typeInfo = semanticModel.GetTypeInfo(memberType);

                if (IsValueType(typeInfo.Type))
                {
                    validMembers.Add(member);
                }
            }

            if (enabled)
            {
                // Determinar o tipo do bitmask baseado na quantidade de campos válidos
                string bitmaskType = validMembers.Count <= 8 ? "byte" :
                                   validMembers.Count <= 16 ? "ushort" :
                                   validMembers.Count <= 32 ? "uint" : "ulong";

                statements.Add(SyntaxFactory.ParseStatement($"{bitmaskType} bytemask = buffer.Read<{bitmaskType}>();"));
                statements.Add(SyntaxFactory.ParseStatement(""));

                int bitIndex = 0;
                foreach (var member in validMembers)
                {
                    string memberName = member is FieldDeclarationSyntax field
                        ? field.Declaration.Variables.First().Identifier.Text
                        : ((PropertyDeclarationSyntax)member).Identifier.Text;

                    TypeSyntax memberType = member is FieldDeclarationSyntax fieldDecl
                        ? fieldDecl.Declaration.Type
                        : ((PropertyDeclarationSyntax)member).Type;

                    var semanticModel = context.Compilation.GetSemanticModel(member.SyntaxTree);
                    var typeInfo = semanticModel.GetTypeInfo(memberType);

                    if (HasPublicMembers(typeInfo.Type))
                    {
                        // Para tipos com campos públicos, deserializar cada campo individualmente
                        var publicMembers = GetPublicMembers(typeInfo.Type);

                        // Criar uma variável temporária para armazenar a nova instância
                        statements.Add(SyntaxFactory.ParseStatement($"var temp{memberName} = {memberName};"));

                        foreach (var pMember in publicMembers)
                        {
                            string memberAccess = "";
                            string memberTypeName = "";

                            if (pMember is IFieldSymbol fieldSymbol)
                            {
                                memberAccess = fieldSymbol.Name;
                                memberTypeName = fieldSymbol.Type.ToString();
                            }
                            else if (pMember is IPropertySymbol propertySymbol)
                            {
                                memberAccess = propertySymbol.Name;
                                memberTypeName = propertySymbol.Type.ToString();
                            }

                            statements.Add(SyntaxFactory.ParseStatement(
                                $"if ((bytemask & ({bitmaskType})(1 << {bitIndex})) != 0) temp{memberName}.{memberAccess} = buffer.Read<{memberTypeName}>();"
                            ));
                            bitIndex++;
                        }

                        // Atribuir a variável temporária de volta ao membro original
                        statements.Add(SyntaxFactory.ParseStatement($"{memberName} = temp{memberName};"));
                    }
                    else
                    {
                        // Para tipos sem campos públicos, deserializar o objeto inteiro
                        statements.Add(SyntaxFactory.ParseStatement(
                            $"if ((bytemask & ({bitmaskType})(1 << {bitIndex})) != 0) {memberName} = buffer.Read<{memberType}>();"
                        ));
                        bitIndex++;
                    }
                }
            }
            else
            {
                // Modo completo - lê todos os campos válidos
                foreach (var member in validMembers)
                {
                    string memberName = member is FieldDeclarationSyntax field
                        ? field.Declaration.Variables.First().Identifier.Text
                        : ((PropertyDeclarationSyntax)member).Identifier.Text;

                    TypeSyntax memberType = member is FieldDeclarationSyntax fieldDecl
                        ? fieldDecl.Declaration.Type
                        : ((PropertyDeclarationSyntax)member).Type;

                    var semanticModel = context.Compilation.GetSemanticModel(member.SyntaxTree);
                    var typeInfo = semanticModel.GetTypeInfo(memberType);

                    if (HasPublicMembers(typeInfo.Type))
                    {
                        // Para tipos com campos públicos, deserializar cada campo individualmente
                        var publicMembers = GetPublicMembers(typeInfo.Type);

                        // Criar uma variável temporária para armazenar a nova instância
                        statements.Add(SyntaxFactory.ParseStatement($"var temp{memberName} = {memberName};"));

                        foreach (var pMember in publicMembers)
                        {
                            string memberAccess = "";
                            string memberTypeName = "";

                            if (pMember is IFieldSymbol fieldSymbol)
                            {
                                memberAccess = fieldSymbol.Name;
                                memberTypeName = fieldSymbol.Type.ToString();
                            }
                            else if (pMember is IPropertySymbol propertySymbol)
                            {
                                memberAccess = propertySymbol.Name;
                                memberTypeName = propertySymbol.Type.ToString();
                            }

                            statements.Add(SyntaxFactory.ParseStatement($"temp{memberName}.{memberAccess} = buffer.Read<{memberTypeName}>();"));
                        }

                        // Atribuir a variável temporária de volta ao membro original
                        statements.Add(SyntaxFactory.ParseStatement($"{memberName} = temp{memberName};"));
                    }
                    else
                    {
                        // Para tipos sem campos públicos, deserializar o objeto inteiro
                        statements.Add(SyntaxFactory.ParseStatement($"{memberName} = buffer.Read<{memberType}>();"));
                    }
                }
            }

            return SyntaxFactory.MethodDeclaration(
                SyntaxFactory.PredefinedType(SyntaxFactory.Token(SyntaxKind.VoidKeyword)),
                "ReadDeltaChanges"
            )
            .WithModifiers(
                SyntaxFactory.TokenList(SyntaxFactory.Token(SyntaxKind.PublicKeyword))
            )
            .WithParameterList(
                SyntaxFactory.ParameterList(
                    SyntaxFactory.SingletonSeparatedList(
                        SyntaxFactory.Parameter(
                            SyntaxFactory.Identifier("buffer")
                        ).WithType(
                            SyntaxFactory.ParseTypeName("DataBuffer")
                        )
                    )
                )
            )
            .WithBody(SyntaxFactory.Block(statements));
        }

        private MethodDeclarationSyntax CreateWriteDeltaMethod(List<MemberDeclarationSyntax> members, string structName, bool enabled, GeneratorExecutionContext context)
        {
            var statements = new List<StatementSyntax>();

            if (enabled)
            {
                // Determinar o tipo do bitmask baseado na quantidade de campos válidos
                string bitmaskType = members.Count <= 8 ? "byte" :
                                   members.Count <= 16 ? "ushort" :
                                   members.Count <= 32 ? "uint" : "ulong";

                statements.Add(SyntaxFactory.ParseStatement($"{bitmaskType} bytemask = 0;"));
                statements.Add(SyntaxFactory.ParseStatement("bool hasChanges = false;"));
                statements.Add(SyntaxFactory.ParseStatement(""));

                int bitIndex = 0;
                foreach (var member in members)
                {
                    string memberName = member is FieldDeclarationSyntax field
                        ? field.Declaration.Variables.First().Identifier.Text
                        : ((PropertyDeclarationSyntax)member).Identifier.Text;

                    TypeSyntax memberType = member is FieldDeclarationSyntax fieldDecl
                        ? fieldDecl.Declaration.Type
                        : ((PropertyDeclarationSyntax)member).Type;

                    var semanticModel = context.Compilation.GetSemanticModel(member.SyntaxTree);
                    var typeInfo = semanticModel.GetTypeInfo(memberType);

                    if (HasPublicMembers(typeInfo.Type))
                    {
                        // Para tipos com campos públicos, comparar cada campo individualmente
                        var publicMembers = GetPublicMembers(typeInfo.Type);
                        foreach (var pMember in publicMembers)
                        {
                            string memberAccess = "";
                            string memberTypeName = "";

                            if (pMember is IFieldSymbol fieldSymbol)
                            {
                                memberAccess = fieldSymbol.Name;
                                memberTypeName = fieldSymbol.Type.ToString();
                            }
                            else if (pMember is IPropertySymbol propertySymbol)
                            {
                                memberAccess = propertySymbol.Name;
                                memberTypeName = propertySymbol.Type.ToString();
                            }

                            statements.Add(SyntaxFactory.ParseStatement(
                                $"if ({memberName}.{memberAccess} != last.{memberName}.{memberAccess}) {{ bytemask |= ({bitmaskType})(1 << {bitIndex}); hasChanges = true; }}"
                            ));
                            bitIndex++;
                        }
                    }
                    else
                    {
                        // Para tipos sem campos públicos, comparar o objeto inteiro
                        statements.Add(SyntaxFactory.ParseStatement(
                            $"if ({memberName} != last.{memberName}) {{ bytemask |= ({bitmaskType})(1 << {bitIndex}); hasChanges = true; }}"
                        ));
                        bitIndex++;
                    }
                }

                statements.Add(SyntaxFactory.ParseStatement(""));
                statements.Add(SyntaxFactory.ParseStatement("DataBuffer buffer = NetworkManager.Pool.Rent();")); // disosed by the caller
                statements.Add(SyntaxFactory.ParseStatement($"buffer.Write(bytemask);"));
                statements.Add(SyntaxFactory.ParseStatement(""));

                bitIndex = 0;
                foreach (var member in members)
                {
                    string memberName = member is FieldDeclarationSyntax field
                        ? field.Declaration.Variables.First().Identifier.Text
                        : ((PropertyDeclarationSyntax)member).Identifier.Text;

                    TypeSyntax memberType = member is FieldDeclarationSyntax fieldDecl
                        ? fieldDecl.Declaration.Type
                        : ((PropertyDeclarationSyntax)member).Type;

                    var semanticModel = context.Compilation.GetSemanticModel(member.SyntaxTree);
                    var typeInfo = semanticModel.GetTypeInfo(memberType);

                    if (HasPublicMembers(typeInfo.Type))
                    {
                        // Para tipos com campos públicos, serializar cada campo individualmente
                        var publicMembers = GetPublicMembers(typeInfo.Type);
                        foreach (var pMember in publicMembers)
                        {
                            string memberAccess = "";
                            string memberTypeName = "";

                            if (pMember is IFieldSymbol fieldSymbol)
                            {
                                memberAccess = fieldSymbol.Name;
                                memberTypeName = fieldSymbol.Type.ToString();
                            }
                            else if (pMember is IPropertySymbol propertySymbol)
                            {
                                memberAccess = propertySymbol.Name;
                                memberTypeName = propertySymbol.Type.ToString();
                            }

                            statements.Add(SyntaxFactory.ParseStatement(
                                $"if ((bytemask & ({bitmaskType})(1 << {bitIndex})) != 0) buffer.Write({memberName}.{memberAccess});"
                            ));
                            bitIndex++;
                        }
                    }
                    else
                    {
                        // Para tipos sem campos públicos, serializar o objeto inteiro
                        statements.Add(SyntaxFactory.ParseStatement(
                            $"if ((bytemask & ({bitmaskType})(1 << {bitIndex})) != 0) buffer.Write({memberName});"
                        ));
                        bitIndex++;
                    }
                }
            }
            else
            {
                // Modo completo - escreve todos os campos válidos
                statements.Add(SyntaxFactory.ParseStatement("bool hasChanges = true;")); // No modo completo, sempre há mudanças
                statements.Add(SyntaxFactory.ParseStatement("DataBuffer buffer = NetworkManager.Pool.Rent();")); // disosed by the caller
                foreach (var member in members)
                {
                    string memberName = member is FieldDeclarationSyntax field
                        ? field.Declaration.Variables.First().Identifier.Text
                        : ((PropertyDeclarationSyntax)member).Identifier.Text;

                    TypeSyntax memberType = member is FieldDeclarationSyntax fieldDecl
                        ? fieldDecl.Declaration.Type
                        : ((PropertyDeclarationSyntax)member).Type;

                    var semanticModel = context.Compilation.GetSemanticModel(member.SyntaxTree);
                    var typeInfo = semanticModel.GetTypeInfo(memberType);

                    if (HasPublicMembers(typeInfo.Type))
                    {
                        // Para tipos com campos públicos, serializar cada campo individualmente
                        var publicMembers = GetPublicMembers(typeInfo.Type);
                        foreach (var pMember in publicMembers)
                        {
                            string memberAccess = "";
                            string memberTypeName = "";

                            if (pMember is IFieldSymbol fieldSymbol)
                            {
                                memberAccess = fieldSymbol.Name;
                                memberTypeName = fieldSymbol.Type.ToString();
                            }
                            else if (pMember is IPropertySymbol propertySymbol)
                            {
                                memberAccess = propertySymbol.Name;
                                memberTypeName = propertySymbol.Type.ToString();
                            }

                            statements.Add(SyntaxFactory.ParseStatement($"buffer.Write({memberName}.{memberAccess});"));
                        }
                    }
                    else
                    {
                        // Para tipos sem campos públicos, serializar o objeto inteiro
                        statements.Add(SyntaxFactory.ParseStatement($"buffer.Write({memberName});"));
                    }
                }
            }

            statements.Add(SyntaxFactory.ParseStatement(""));
            statements.Add(SyntaxFactory.ParseStatement("last = this;"));
            statements.Add(SyntaxFactory.ParseStatement("changed = hasChanges;"));
            statements.Add(SyntaxFactory.ParseStatement("return buffer;"));

            return SyntaxFactory.MethodDeclaration(
                SyntaxFactory.ParseTypeName("DataBuffer"),
                "WriteDeltaChanges"
            )
            .WithModifiers(
                SyntaxFactory.TokenList(SyntaxFactory.Token(SyntaxKind.PublicKeyword))
            )
            .WithParameterList(
                SyntaxFactory.ParameterList(
                    SyntaxFactory.SeparatedList<ParameterSyntax>(
                        new SyntaxNodeOrToken[] {
                            SyntaxFactory.Parameter(
                                SyntaxFactory.Identifier("last")
                            ).WithModifiers(
                                SyntaxFactory.TokenList(
                                    SyntaxFactory.Token(SyntaxKind.RefKeyword)
                                )
                            ).WithType(
                                SyntaxFactory.ParseTypeName(structName)
                            ),
                            SyntaxFactory.Token(SyntaxKind.CommaToken),
                            SyntaxFactory.Parameter(
                                SyntaxFactory.Identifier("changed")
                            ).WithModifiers(
                                SyntaxFactory.TokenList(
                                    SyntaxFactory.Token(SyntaxKind.OutKeyword)
                                )
                            ).WithType(
                                SyntaxFactory.PredefinedType(
                                    SyntaxFactory.Token(SyntaxKind.BoolKeyword)
                                )
                            )
                        }
                    )
                )
            )
            .WithBody(SyntaxFactory.Block(statements));
        }

        private bool IsValueType(ITypeSymbol typeSymbol)
        {
            return typeSymbol != null && typeSymbol.IsValueType;
        }

        private bool HasPublicMembers(ITypeSymbol typeSymbol)
        {
            if (typeSymbol == null) return false;

            return typeSymbol.GetMembers()
                .Any(m =>
                    (m is IFieldSymbol field &&
                     field.DeclaredAccessibility == Accessibility.Public &&
                     !field.IsConst &&
                     !field.IsStatic && IsValueType(typeSymbol)) ||
                    (m is IPropertySymbol property &&
                     property.DeclaredAccessibility == Accessibility.Public &&
                     !property.IsStatic)
                );
        }

        private IEnumerable<ISymbol> GetPublicMembers(ITypeSymbol typeSymbol)
        {
            if (typeSymbol == null) return Enumerable.Empty<ISymbol>();

            return typeSymbol.GetMembers()
                .Where(m =>
                    (m is IFieldSymbol field &&
                     field.DeclaredAccessibility == Accessibility.Public &&
                     !field.IsConst &&
                     !field.IsStatic) ||
                    (m is IPropertySymbol property &&
                     property.DeclaredAccessibility == Accessibility.Public &&
                     !property.IsStatic)
                );
        }

        public void Initialize(GeneratorInitializationContext context)
        {
            context.RegisterForSyntaxNotifications(() => new DeltaSerializableSyntaxReceiver());
        }
    }

    public class DeltaSerializableSyntaxReceiver : ISyntaxReceiver
    {
        internal List<StructDeclarationSyntax> structs = new List<StructDeclarationSyntax>();
        public void OnVisitSyntaxNode(SyntaxNode syntaxNode)
        {
            if (syntaxNode is StructDeclarationSyntax structDeclaration)
            {
                if (structDeclaration.HasAttribute("DeltaSerializable"))
                {
                    structs.Add(structDeclaration);
                }
            }
        }
    }
}
